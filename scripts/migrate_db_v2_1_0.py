#!/usr/bin/env python3
"""
Migraci√≥n de Base de Datos v2.1.0
A√±ade soporte para dobles, triples y Elige 8 manteniendo compatibilidad

Autor: Sistema 1x2_Predictor
Fecha: 15 Agosto 2025
"""

import os
import sys
import logging
from datetime import datetime
from pathlib import Path

# A√±adir el directorio ra√≠z al path para importar m√≥dulos
sys.path.append(str(Path(__file__).parent.parent))

from backend.app.database.connection import get_db
from backend.app.database.models import Base, engine
from sqlalchemy import text, inspect, Column, String, Integer, Float, Boolean, JSON
from sqlalchemy.exc import OperationalError, ProgrammingError

# Configurar logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)


class DatabaseMigrator:
    """Migrador de base de datos con rollback autom√°tico"""
    
    def __init__(self):
        self.db = next(get_db())
        self.inspector = inspect(engine)
        self.backup_tables = []
        
    def check_column_exists(self, table_name: str, column_name: str) -> bool:
        """Verificar si una columna existe en la tabla"""
        try:
            columns = self.inspector.get_columns(table_name)
            return any(col['name'] == column_name for col in columns)
        except Exception as e:
            logger.warning(f"No se pudo verificar columna {column_name} en {table_name}: {e}")
            return False
    
    def backup_critical_data(self):
        """Crear backup de datos cr√≠ticos antes de migraci√≥n"""
        logger.info("üîÑ Creando backup de datos cr√≠ticos...")
        
        try:
            # Backup de quinielas de usuario
            result = self.db.execute(text("SELECT COUNT(*) FROM user_quinielas"))
            user_quinielas_count = result.scalar()
            
            result = self.db.execute(text("SELECT COUNT(*) FROM user_quiniela_predictions"))
            predictions_count = result.scalar()
            
            logger.info(f"üìä Datos a preservar:")
            logger.info(f"   ‚Ä¢ Quinielas de usuario: {user_quinielas_count}")
            logger.info(f"   ‚Ä¢ Predicciones: {predictions_count}")
            
            # Crear tabla temporal de backup si hay datos importantes
            if user_quinielas_count > 0:
                self.db.execute(text("""
                    CREATE TABLE IF NOT EXISTS backup_user_quinielas_v2_1_0 AS 
                    SELECT * FROM user_quinielas
                """))
                logger.info("‚úÖ Backup de user_quinielas creado")
            
            if predictions_count > 0:
                self.db.execute(text("""
                    CREATE TABLE IF NOT EXISTS backup_user_quiniela_predictions_v2_1_0 AS 
                    SELECT * FROM user_quiniela_predictions
                """))
                logger.info("‚úÖ Backup de predicciones creado")
                
            self.db.commit()
            
        except Exception as e:
            logger.error(f"‚ùå Error creando backup: {e}")
            self.db.rollback()
            raise
    
    def add_column_if_not_exists(self, table_name: str, column_definition: str):
        """A√±adir columna si no existe"""
        column_name = column_definition.split()[0]
        
        if not self.check_column_exists(table_name, column_name):
            try:
                logger.info(f"‚ûï A√±adiendo columna {column_name} a {table_name}")
                self.db.execute(text(f"ALTER TABLE {table_name} ADD COLUMN {column_definition}"))
                logger.info(f"‚úÖ Columna {column_name} a√±adida exitosamente")
            except Exception as e:
                logger.error(f"‚ùå Error a√±adiendo columna {column_name}: {e}")
                raise
        else:
            logger.info(f"‚ÑπÔ∏è Columna {column_name} ya existe en {table_name}")
    
    def migrate_user_quinielas(self):
        """Migrar tabla user_quinielas para soporte dobles/triples/Elige8"""
        logger.info("üîÑ Migrando tabla user_quinielas...")
        
        # Nuevas columnas para sistema de dobles y triples
        new_columns = [
            "bet_type VARCHAR(20) DEFAULT 'simple'",
            "total_combinations INTEGER DEFAULT 1",
            "base_cost FLOAT DEFAULT 0.75",
            
            # Campos para Elige 8
            "elige_8_enabled BOOLEAN DEFAULT FALSE",
            "elige_8_matches JSON",
            "elige_8_cost FLOAT DEFAULT 0.0",
            "elige_8_predictions JSON"
        ]
        
        for column_def in new_columns:
            self.add_column_if_not_exists("user_quinielas", column_def)
        
        # Actualizar datos existentes con valores por defecto
        try:
            logger.info("üîÑ Actualizando quinielas existentes con valores por defecto...")
            
            # Calcular costo base correcto para quinielas existentes
            self.db.execute(text("""
                UPDATE user_quinielas 
                SET 
                    bet_type = 'simple',
                    total_combinations = 1,
                    base_cost = COALESCE(cost, 0.75),
                    elige_8_enabled = FALSE,
                    elige_8_cost = 0.0
                WHERE bet_type IS NULL
            """))
            
            updated_rows = self.db.rowcount
            logger.info(f"‚úÖ {updated_rows} quinielas existentes actualizadas")
            
        except Exception as e:
            logger.error(f"‚ùå Error actualizando datos existentes: {e}")
            raise
    
    def migrate_user_quiniela_predictions(self):
        """Migrar tabla user_quiniela_predictions para soporte m√∫ltiple"""
        logger.info("üîÑ Migrando tabla user_quiniela_predictions...")
        
        # Nuevas columnas para predicciones m√∫ltiples
        new_columns = [
            "multiplicity INTEGER DEFAULT 1",
            "prediction_options JSON"
        ]
        
        for column_def in new_columns:
            self.add_column_if_not_exists("user_quiniela_predictions", column_def)
        
        # Convertir predicciones existentes al nuevo formato
        try:
            logger.info("üîÑ Convirtiendo predicciones existentes al nuevo formato...")
            
            self.db.execute(text("""
                UPDATE user_quiniela_predictions 
                SET 
                    multiplicity = 1,
                    prediction_options = JSON_ARRAY(user_prediction)
                WHERE multiplicity IS NULL AND user_prediction IS NOT NULL
            """))
            
            updated_rows = self.db.rowcount
            logger.info(f"‚úÖ {updated_rows} predicciones convertidas al nuevo formato")
            
        except Exception as e:
            logger.error(f"‚ùå Error convirtiendo predicciones: {e}")
            raise
    
    def verify_migration(self):
        """Verificar que la migraci√≥n fue exitosa"""
        logger.info("üîç Verificando migraci√≥n...")
        
        # Verificar columnas de user_quinielas
        required_columns = [
            'bet_type', 'total_combinations', 'base_cost',
            'elige_8_enabled', 'elige_8_matches', 'elige_8_cost', 'elige_8_predictions'
        ]
        
        for column in required_columns:
            if not self.check_column_exists('user_quinielas', column):
                raise Exception(f"Migraci√≥n fallida: columna {column} no existe en user_quinielas")
        
        # Verificar columnas de user_quiniela_predictions
        prediction_columns = ['multiplicity', 'prediction_options']
        
        for column in prediction_columns:
            if not self.check_column_exists('user_quiniela_predictions', column):
                raise Exception(f"Migraci√≥n fallida: columna {column} no existe en user_quiniela_predictions")
        
        # Verificar integridad de datos
        try:
            result = self.db.execute(text("""
                SELECT COUNT(*) FROM user_quinielas 
                WHERE bet_type IS NULL OR total_combinations IS NULL
            """))
            null_count = result.scalar()
            
            if null_count > 0:
                raise Exception(f"Migraci√≥n fallida: {null_count} registros con datos nulos")
            
            logger.info("‚úÖ Verificaci√≥n de migraci√≥n exitosa")
            
        except Exception as e:
            logger.error(f"‚ùå Error en verificaci√≥n: {e}")
            raise
    
    def cleanup_backup_tables(self):
        """Limpiar tablas de backup despu√©s de migraci√≥n exitosa"""
        logger.info("üßπ Limpiando tablas de backup...")
        
        try:
            # Solo limpiar si la migraci√≥n fue completamente exitosa
            backup_tables = [
                'backup_user_quinielas_v2_1_0',
                'backup_user_quiniela_predictions_v2_1_0'
            ]
            
            for table in backup_tables:
                try:
                    self.db.execute(text(f"DROP TABLE IF EXISTS {table}"))
                    logger.info(f"üóëÔ∏è Tabla backup {table} eliminada")
                except Exception as e:
                    logger.warning(f"‚ö†Ô∏è No se pudo eliminar tabla backup {table}: {e}")
            
        except Exception as e:
            logger.warning(f"‚ö†Ô∏è Error limpiando backups: {e}")
    
    def rollback_migration(self):
        """Rollback en caso de error cr√≠tico"""
        logger.error("üîÑ Ejecutando rollback de migraci√≥n...")
        
        try:
            self.db.rollback()
            logger.info("‚úÖ Rollback de transacci√≥n completado")
            
            # Informar sobre tablas de backup disponibles
            logger.info("üì¶ Tablas de backup disponibles para restauraci√≥n manual:")
            logger.info("   ‚Ä¢ backup_user_quinielas_v2_1_0")
            logger.info("   ‚Ä¢ backup_user_quiniela_predictions_v2_1_0")
            
        except Exception as e:
            logger.error(f"‚ùå Error en rollback: {e}")
    
    def run_migration(self):
        """Ejecutar migraci√≥n completa"""
        logger.info("üöÄ Iniciando migraci√≥n de base de datos v2.1.0")
        logger.info("üìã A√±adiendo soporte para dobles, triples y Elige 8")
        
        try:
            # Paso 1: Backup de datos cr√≠ticos
            self.backup_critical_data()
            
            # Paso 2: Migrar user_quinielas
            self.migrate_user_quinielas()
            
            # Paso 3: Migrar user_quiniela_predictions
            self.migrate_user_quiniela_predictions()
            
            # Paso 4: Commit de cambios
            self.db.commit()
            logger.info("üíæ Cambios guardados en base de datos")
            
            # Paso 5: Verificar migraci√≥n
            self.verify_migration()
            
            # Paso 6: Limpiar backups (opcional)
            # self.cleanup_backup_tables()  # Comentado para mantener backups por seguridad
            
            logger.info("üéâ Migraci√≥n v2.1.0 completada exitosamente")
            logger.info("‚úÖ Sistema listo para dobles, triples y Elige 8")
            
            return True
            
        except Exception as e:
            logger.error(f"‚ùå Error en migraci√≥n: {e}")
            self.rollback_migration()
            return False
        
        finally:
            self.db.close()


def main():
    """Funci√≥n principal para ejecutar migraci√≥n"""
    print("üéØ Migraci√≥n Base de Datos v2.1.0 - Dobles, Triples y Elige 8")
    print("=" * 60)
    
    try:
        # Verificar conexi√≥n a base de datos
        logger.info("üîå Verificando conexi√≥n a base de datos...")
        migrator = DatabaseMigrator()
        logger.info("‚úÖ Conexi√≥n establecida correctamente")
        
        # Mostrar informaci√≥n del estado actual
        logger.info("üìä Analizando estado actual de la base de datos...")
        
        # Ejecutar migraci√≥n
        success = migrator.run_migration()
        
        if success:
            print("\nüéâ ¬°MIGRACI√ìN EXITOSA!")
            print("‚úÖ Base de datos actualizada a v2.1.0")
            print("üöÄ Sistema listo para usar dobles, triples y Elige 8")
            print("\nüìã Pr√≥ximos pasos:")
            print("   1. Implementar endpoints API para dobles/triples")
            print("   2. Desarrollar interfaz dashboard")
            print("   3. Testing completo del sistema")
            return 0
        else:
            print("\n‚ùå MIGRACI√ìN FALLIDA")
            print("üîÑ Se ha ejecutado rollback autom√°tico")
            print("üì¶ Tablas de backup disponibles para restauraci√≥n manual")
            return 1
            
    except Exception as e:
        logger.error(f"üí• Error cr√≠tico en migraci√≥n: {e}")
        print(f"\nüí• Error cr√≠tico: {e}")
        return 1


if __name__ == "__main__":
    exit_code = main()
    exit(exit_code)